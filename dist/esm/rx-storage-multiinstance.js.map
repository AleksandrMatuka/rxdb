{"version":3,"file":"rx-storage-multiinstance.js","names":["Subject","mergeWith","BroadcastChannel","PROMISE_RESOLVE_VOID","BROADCAST_CHANNEL_BY_TOKEN","Map","getBroadcastChannelReference","storageName","databaseInstanceToken","databaseName","refObject","state","get","bc","join","refs","Set","set","add","removeBroadcastChannelReference","delete","size","close","addRxStorageMultiInstanceSupport","instanceCreationParams","instance","providedBroadcastChannel","multiInstance","broadcastChannel","changesFromOtherInstances$","eventListener","msg","collectionName","version","schema","next","eventBulk","returnPromise","postMessage","then","addEventListener","oldChangestream$","changeStream","closed","sub","subscribe","asObservable","pipe","oldClose","bind","unsubscribe","removeEventListener","oldRemove","remove"],"sources":["../../src/rx-storage-multiinstance.ts"],"sourcesContent":["/**\n * When a persistent RxStorage is used in more the one JavaScript process,\n * the even stream of the changestream() function must be broadcasted to the other\n * RxStorageInstances of the same databaseName+collectionName.\n *\n * In the past this was done by RxDB but it makes more sense to do this\n * at the RxStorage level so that the broadcasting etc can all happen inside of a WebWorker\n * and not on the main thread.\n * Also it makes it less complex to stack up different RxStorages onto each other\n * like what we do with the in-memory plugin.\n *\n * This is intended to be used inside of createStorageInstance() of a storage.\n * Do not use this if the storage anyway broadcasts the events like when using MongoDB\n * or in the future W3C might introduce a way to listen to IndexedDB changes.\n */\n\nimport { Observable, Subject } from 'rxjs';\nimport { mergeWith } from 'rxjs/operators';\nimport type {\n    EventBulk,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams\n} from './types/index.d.ts';\n\nimport {\n    BroadcastChannel\n} from 'broadcast-channel';\nimport {\n    PROMISE_RESOLVE_VOID\n} from './plugins/utils/index.ts';\n\n/**\n * The broadcast-channel is reused by the databaseInstanceToken.\n * This is required so that it is easy to simulate multi-tab usage\n * in the test where different instances of the same RxDatabase must\n * have different broadcast channels.\n * But also it ensures that for each RxDatabase we only create a single\n * broadcast channel that can even be reused in the leader election plugin.\n *\n * TODO at the end of the unit tests,\n * we should ensure that all channels are closed and cleaned up.\n * Otherwise we have forgot something.\n */\nexport const BROADCAST_CHANNEL_BY_TOKEN: Map<string, {\n    bc: BroadcastChannel<RxStorageMultiInstanceBroadcastType>;\n    /**\n     * Contains all context objects that currently use the channel.\n     * If this becomes empty, we can close the channel\n     */\n    refs: Set<any>;\n}> = new Map();\n\n\nexport type RxStorageMultiInstanceBroadcastType = {\n    storageName: string;\n    collectionName: string;\n    /**\n     * collection.schema.version\n     */\n    version: number;\n    databaseName: string;\n    eventBulk: EventBulk<any, any>;\n};\n\nexport function getBroadcastChannelReference(\n    storageName: string,\n    databaseInstanceToken: string,\n    databaseName: string,\n    refObject: any\n): BroadcastChannel<RxStorageMultiInstanceBroadcastType> {\n    let state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n    if (!state) {\n        state = {\n            /**\n             * We have to use the databaseName instead of the databaseInstanceToken\n             * in the BroadcastChannel name because different instances must end with the same\n             * channel name to be able to broadcast messages between each other.\n             */\n            bc: new BroadcastChannel(['RxDB:', storageName, databaseName].join('|')),\n            refs: new Set<any>()\n        };\n        BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);\n    }\n    state.refs.add(refObject);\n    return state.bc;\n}\n\nexport function removeBroadcastChannelReference(\n    databaseInstanceToken: string,\n    refObject: any\n) {\n    const state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);\n    if (!state) {\n        return;\n    }\n    state.refs.delete(refObject);\n    if (state.refs.size === 0) {\n        BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);\n        return state.bc.close();\n    }\n}\n\n\nexport function addRxStorageMultiInstanceSupport<RxDocType>(\n    storageName: string,\n    instanceCreationParams: RxStorageInstanceCreationParams<RxDocType, any>,\n    instance: RxStorageInstance<RxDocType, any, any>,\n    /**\n     * If provided, that channel will be used\n     * instead of an own one.\n     */\n    providedBroadcastChannel?: BroadcastChannel<any>\n): Promise<void> {\n    if (!instanceCreationParams.multiInstance) {\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    type Emit = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n\n    const broadcastChannel = providedBroadcastChannel ?\n        providedBroadcastChannel :\n        getBroadcastChannelReference(\n            storageName,\n            instanceCreationParams.databaseInstanceToken,\n            instance.databaseName,\n            instance\n        );\n\n    const changesFromOtherInstances$: Subject<Emit> = new Subject();\n\n\n    const eventListener = (msg: RxStorageMultiInstanceBroadcastType) => {\n        if (\n            msg.storageName === storageName &&\n            msg.databaseName === instanceCreationParams.databaseName &&\n            msg.collectionName === instanceCreationParams.collectionName &&\n            msg.version === instanceCreationParams.schema.version\n        ) {\n            changesFromOtherInstances$.next(msg.eventBulk);\n        }\n    };\n\n    /**\n     * Here we send one blank message. This is important for\n     * test cases where a 2nd multi-instance collection\n     * is directly created after an insert. Without this\n     * the new collection would directly emit the insert event\n     * which would then cause wrong results.\n     * By sending the blank message we can ensure that all messages\n     * from postMessage() calls that happened before the call to addRxStorageMultiInstanceSupport()\n     * have already been processed.\n     */\n    const returnPromise = broadcastChannel.postMessage({} as any).then(() => {\n        broadcastChannel.addEventListener('message', eventListener);\n    });\n\n    const oldChangestream$ = instance.changeStream();\n\n    let closed = false;\n    const sub = oldChangestream$.subscribe(eventBulk => {\n        if (closed) {\n            return;\n        }\n        broadcastChannel.postMessage({\n            storageName: storageName,\n            databaseName: instanceCreationParams.databaseName,\n            collectionName: instanceCreationParams.collectionName,\n            version: instanceCreationParams.schema.version,\n            eventBulk\n        });\n    });\n\n    instance.changeStream = function (): Observable<Emit> {\n        return changesFromOtherInstances$.asObservable().pipe(\n            mergeWith(oldChangestream$)\n        );\n    };\n\n    const oldClose = instance.close.bind(instance);\n    instance.close = async function () {\n        closed = true;\n        sub.unsubscribe();\n        broadcastChannel.removeEventListener('message', eventListener);\n        if (!providedBroadcastChannel) {\n            await removeBroadcastChannelReference(\n                instanceCreationParams.databaseInstanceToken,\n                instance\n            );\n        }\n        return oldClose();\n    };\n\n    const oldRemove = instance.remove.bind(instance);\n    instance.remove = async function () {\n        closed = true;\n        sub.unsubscribe();\n        broadcastChannel.removeEventListener('message', eventListener);\n        if (!providedBroadcastChannel) {\n            await removeBroadcastChannelReference(\n                instanceCreationParams.databaseInstanceToken,\n                instance\n            );\n        }\n        return oldRemove();\n    };\n\n    return returnPromise;\n}\n"],"mappings":"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"}