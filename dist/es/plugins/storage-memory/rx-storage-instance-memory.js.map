{"version":3,"file":"rx-storage-instance-memory.js","names":["Subject","getStartIndexStringFromLowerBound","getStartIndexStringFromUpperBound","getPrimaryFieldOfPrimaryKey","categorizeBulkWriteRows","ensureNotFalsy","getFromMapOrThrow","lastOfArray","now","PROMISE_RESOLVE_TRUE","PROMISE_RESOLVE_VOID","RX_META_LWT_MINIMUM","boundGE","boundGT","boundLE","boundLT","attachmentMapKey","compareDocsWithIndex","ensureNotRemoved","getMemoryCollectionKey","putWriteRowToState","removeDocFromState","addIndexesToInternalsState","getMemoryIndexName","getQueryMatcher","getSortComparator","RxStorageInstanceMemory","storage","databaseName","collectionName","schema","internals","options","settings","closed","primaryPath","primaryKey","_proto","prototype","bulkWrite","documentWrites","context","documentsById","documents","success","error","categorized","errors","stateByIndex","Object","values","byIndex","bulkInsertDocs","i","length","writeRow","docId","document","undefined","bulkUpdateDocs","get","attachments","attachmentsMap","attachmentsAdd","forEach","attachment","set","documentId","attachmentId","writeData","attachmentData","digest","attachmentsUpdate","attachmentsRemove","delete","eventBulk","events","lastState","newestRow","checkpoint","id","lwt","_meta","changes$","next","Promise","resolve","findDocumentsById","docIds","withDeleted","ret","docInDb","_deleted","query","preparedQuery","queryPlan","skip","limit","Infinity","skipPlusLimit","queryMatcher","selectorSatisfiedByIndex","queryPlanFields","index","mustManuallyResort","sortFieldsSameAsIndexFields","concat","lowerBound","startKeys","lowerBoundString","inclusiveStart","upperBound","endKeys","upperBoundString","inclusiveEnd","indexName","docsWithIndex","indexOfLower","indexString","indexOfUpper","rows","done","currentRow","currentDoc","doc","push","sortComparator","sort","slice","count","result","mode","getChangedDocumentsSince","sinceLwt","sinceId","lastDoc","cleanup","minimumDeletedTime","maxDeletionTime","getAttachmentData","data","Error","changeStream","asObservable","remove","removed","collectionStates","version","close","reject","refCount","conflictResultionTasks","conflictResultionTasks$","resolveConflictResultionTask","_taskSolution","createMemoryStorageInstance","params","collectionKey","Map","instance"],"sources":["../../../../src/plugins/storage-memory/rx-storage-instance-memory.ts"],"sourcesContent":["import {\n    Observable,\n    Subject\n} from 'rxjs';\nimport {\n    getStartIndexStringFromLowerBound,\n    getStartIndexStringFromUpperBound\n} from '../../custom-index';\nimport { getPrimaryFieldOfPrimaryKey } from '../../rx-schema-helper';\nimport {\n    categorizeBulkWriteRows\n} from '../../rx-storage-helper';\nimport type {\n    BulkWriteRow,\n    ById,\n    EventBulk,\n    QueryMatcher,\n    RxConflictResultionTask,\n    RxConflictResultionTaskSolution,\n    RxDocumentData,\n    RxDocumentDataById,\n    RxJsonSchema,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageCountResult,\n    RxStorageDefaultCheckpoint,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxStorageQueryResult,\n    RxStorageWriteError,\n    StringKeys\n} from '../../types';\nimport {\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    lastOfArray,\n    now,\n    PROMISE_RESOLVE_TRUE,\n    PROMISE_RESOLVE_VOID,\n    RX_META_LWT_MINIMUM\n} from '../../plugins/utils';\nimport {\n    boundGE,\n    boundGT,\n    boundLE,\n    boundLT\n} from './binary-search-bounds';\nimport {\n    attachmentMapKey,\n    compareDocsWithIndex,\n    ensureNotRemoved,\n    getMemoryCollectionKey,\n    putWriteRowToState,\n    removeDocFromState\n} from './memory-helper';\nimport {\n    addIndexesToInternalsState,\n    getMemoryIndexName\n} from './memory-indexes';\nimport type {\n    MemoryPreparedQuery,\n    MemoryStorageInternals,\n    RxStorageMemory,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageMemorySettings\n} from './memory-types';\nimport { getQueryMatcher, getSortComparator } from '../../rx-query-helper';\n\nexport class RxStorageInstanceMemory<RxDocType> implements RxStorageInstance<\n    RxDocType,\n    MemoryStorageInternals<RxDocType>,\n    RxStorageMemoryInstanceCreationOptions,\n    RxStorageDefaultCheckpoint\n> {\n\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public closed = false;\n\n    constructor(\n        public readonly storage: RxStorageMemory,\n        public readonly databaseName: string,\n        public readonly collectionName: string,\n        public readonly schema: Readonly<RxJsonSchema<RxDocumentData<RxDocType>>>,\n        public readonly internals: MemoryStorageInternals<RxDocType>,\n        public readonly options: Readonly<RxStorageMemoryInstanceCreationOptions>,\n        public readonly settings: RxStorageMemorySettings\n    ) {\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);\n    }\n\n    bulkWrite(\n        documentWrites: BulkWriteRow<RxDocType>[],\n        context: string\n    ): Promise<RxStorageBulkWriteResponse<RxDocType>> {\n        ensureNotRemoved(this);\n        const internals = this.internals;\n        const documentsById = this.internals.documents;\n        const primaryPath = this.primaryPath;\n\n        const success: RxDocumentDataById<RxDocType> = {};\n        let error: ById<RxStorageWriteError<RxDocType>> = {};\n\n        const categorized = categorizeBulkWriteRows<RxDocType>(\n            this,\n            primaryPath as any,\n            documentsById,\n            documentWrites,\n            context\n        );\n        error = categorized.errors;\n\n        /**\n         * Do inserts/updates\n         */\n        const stateByIndex = Object.values(this.internals.byIndex);\n\n        const bulkInsertDocs = categorized.bulkInsertDocs;\n        for (let i = 0; i < bulkInsertDocs.length; ++i) {\n            const writeRow = bulkInsertDocs[i];\n            const docId = writeRow.document[primaryPath];\n            putWriteRowToState(\n                docId as any,\n                internals,\n                stateByIndex,\n                writeRow,\n                undefined\n            );\n            success[docId as any] = writeRow.document;\n        }\n\n        const bulkUpdateDocs = categorized.bulkUpdateDocs;\n        for (let i = 0; i < bulkUpdateDocs.length; ++i) {\n            const writeRow = bulkUpdateDocs[i];\n            const docId = writeRow.document[primaryPath];\n            putWriteRowToState(\n                docId as any,\n                internals,\n                stateByIndex,\n                writeRow,\n                documentsById.get(docId as any)\n            );\n            success[docId as any] = writeRow.document;\n        }\n\n        /**\n         * Handle attachments\n         */\n        if (this.schema.attachments) {\n            const attachmentsMap = internals.attachments;\n            categorized.attachmentsAdd.forEach(attachment => {\n                attachmentsMap.set(\n                    attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                    {\n                        writeData: attachment.attachmentData,\n                        digest: attachment.digest\n                    }\n                );\n            });\n            if (this.schema.attachments) {\n                categorized.attachmentsUpdate.forEach(attachment => {\n                    attachmentsMap.set(\n                        attachmentMapKey(attachment.documentId, attachment.attachmentId),\n                        {\n                            writeData: attachment.attachmentData,\n                            digest: attachment.digest\n                        }\n                    );\n                });\n                categorized.attachmentsRemove.forEach(attachment => {\n                    attachmentsMap.delete(\n                        attachmentMapKey(attachment.documentId, attachment.attachmentId)\n                    );\n                });\n            }\n        }\n\n        if (categorized.eventBulk.events.length > 0) {\n            const lastState = ensureNotFalsy(categorized.newestRow).document;\n            categorized.eventBulk.checkpoint = {\n                id: lastState[primaryPath],\n                lwt: lastState._meta.lwt\n            };\n            internals.changes$.next(categorized.eventBulk);\n        }\n        return Promise.resolve({ success, error });\n    }\n\n    findDocumentsById(\n        docIds: string[],\n        withDeleted: boolean\n    ): Promise<RxDocumentDataById<RxDocType>> {\n        const documentsById = this.internals.documents;\n        const ret: RxDocumentDataById<RxDocType> = {};\n        for (let i = 0; i < docIds.length; ++i) {\n            const docId = docIds[i];\n            const docInDb = documentsById.get(docId);\n            if (\n                docInDb &&\n                (\n                    !docInDb._deleted ||\n                    withDeleted\n                )\n            ) {\n                ret[docId] = docInDb;\n            }\n        }\n        return Promise.resolve(ret);\n    }\n\n    query(\n        preparedQuery: MemoryPreparedQuery<RxDocType>\n    ): Promise<RxStorageQueryResult<RxDocType>> {\n        const queryPlan = preparedQuery.queryPlan;\n        const query = preparedQuery.query;\n\n        const skip = query.skip ? query.skip : 0;\n        const limit = query.limit ? query.limit : Infinity;\n        const skipPlusLimit = skip + limit;\n\n        let queryMatcher: QueryMatcher<RxDocumentData<RxDocType>> | false = false;\n        if (!queryPlan.selectorSatisfiedByIndex) {\n            queryMatcher = getQueryMatcher(\n                this.schema,\n                preparedQuery.query\n            );\n        }\n\n        const queryPlanFields: string[] = queryPlan.index;\n        const mustManuallyResort = !queryPlan.sortFieldsSameAsIndexFields;\n        const index: string[] | undefined = ['_deleted'].concat(queryPlanFields);\n        let lowerBound: any[] = queryPlan.startKeys;\n        lowerBound = [false].concat(lowerBound);\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            lowerBound,\n            queryPlan.inclusiveStart\n        );\n\n        let upperBound: any[] = queryPlan.endKeys;\n        upperBound = [false].concat(upperBound);\n        const upperBoundString = getStartIndexStringFromUpperBound(\n            this.schema,\n            index,\n            upperBound,\n            queryPlan.inclusiveEnd\n        );\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        let indexOfLower = (queryPlan.inclusiveStart ? boundGE : boundGT)(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n        const indexOfUpper = (queryPlan.inclusiveEnd ? boundLE : boundLT)(\n            docsWithIndex,\n            {\n                indexString: upperBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let rows: RxDocumentData<RxDocType>[] = [];\n        let done = false;\n        while (!done) {\n            const currentRow = docsWithIndex[indexOfLower];\n            if (\n                !currentRow ||\n                indexOfLower > indexOfUpper\n            ) {\n                break;\n            }\n            const currentDoc = currentRow.doc;\n\n            if (!queryMatcher || queryMatcher(currentDoc)) {\n                rows.push(currentDoc);\n            }\n\n            if (\n                (rows.length >= skipPlusLimit && !mustManuallyResort) ||\n                indexOfLower >= docsWithIndex.length\n            ) {\n                done = true;\n            }\n\n            indexOfLower++;\n        }\n\n        if (mustManuallyResort) {\n            const sortComparator = getSortComparator(this.schema, preparedQuery.query);\n            rows = rows.sort(sortComparator);\n        }\n\n        // apply skip and limit boundaries.\n        rows = rows.slice(skip, skipPlusLimit);\n        return Promise.resolve({\n            documents: rows\n        });\n    }\n\n    async count(\n        preparedQuery: MemoryPreparedQuery<RxDocType>\n    ): Promise<RxStorageCountResult> {\n        const result = await this.query(preparedQuery);\n        return {\n            count: result.documents.length,\n            mode: 'fast'\n        };\n    }\n\n    getChangedDocumentsSince(\n        limit: number,\n        checkpoint?: RxStorageDefaultCheckpoint\n    ): Promise<{\n        documents: RxDocumentData<RxDocType>[];\n        checkpoint: RxStorageDefaultCheckpoint;\n    }> {\n        const sinceLwt = checkpoint ? checkpoint.lwt : RX_META_LWT_MINIMUM;\n        const sinceId = checkpoint ? checkpoint.id : '';\n\n        const index = ['_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            ['_meta.lwt', this.primaryPath as any],\n            [\n                sinceLwt,\n                sinceId\n            ],\n            false\n        );\n\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        // TODO use array.slice() so we do not have to iterate here\n        const rows: RxDocumentData<RxDocType>[] = [];\n        while (rows.length < limit && indexOfLower < docsWithIndex.length) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            rows.push(currentDoc.doc);\n            indexOfLower++;\n        }\n\n        const lastDoc = lastOfArray(rows);\n        return Promise.resolve({\n            documents: rows,\n            checkpoint: lastDoc ? {\n                id: lastDoc[this.primaryPath] as any,\n                lwt: lastDoc._meta.lwt\n            } : checkpoint ? checkpoint : {\n                id: '',\n                lwt: 0\n            }\n        });\n    }\n\n    cleanup(minimumDeletedTime: number): Promise<boolean> {\n        const maxDeletionTime = now() - minimumDeletedTime;\n        const index = ['_deleted', '_meta.lwt', this.primaryPath as any];\n        const indexName = getMemoryIndexName(index);\n        const docsWithIndex = this.internals.byIndex[indexName].docsWithIndex;\n\n        const lowerBoundString = getStartIndexStringFromLowerBound(\n            this.schema,\n            index,\n            [\n                true,\n                0,\n                ''\n            ],\n            false\n        );\n\n        let indexOfLower = boundGT(\n            docsWithIndex,\n            {\n                indexString: lowerBoundString\n            } as any,\n            compareDocsWithIndex\n        );\n\n        let done = false;\n        while (!done) {\n            const currentDoc = docsWithIndex[indexOfLower];\n            if (!currentDoc || currentDoc.doc._meta.lwt > maxDeletionTime) {\n                done = true;\n            } else {\n                removeDocFromState(\n                    this.primaryPath as any,\n                    this.schema,\n                    this.internals,\n                    currentDoc.doc\n                );\n                indexOfLower++;\n            }\n        }\n        return PROMISE_RESOLVE_TRUE;\n    }\n\n    getAttachmentData(\n        documentId: string,\n        attachmentId: string,\n        digest: string\n    ): Promise<string> {\n        ensureNotRemoved(this);\n        const data = getFromMapOrThrow(\n            this.internals.attachments,\n            attachmentMapKey(documentId, attachmentId)\n        );\n        if (\n            !digest ||\n            data.digest !== digest\n        ) {\n            throw new Error('attachment does not exist');\n        }\n        return Promise.resolve(data.writeData.data);\n    }\n\n    changeStream(): Observable<EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, RxStorageDefaultCheckpoint>> {\n        ensureNotRemoved(this);\n        return this.internals.changes$.asObservable();\n    }\n\n    async remove(): Promise<void> {\n        ensureNotRemoved(this);\n\n        this.internals.removed = true;\n        this.storage.collectionStates.delete(\n            getMemoryCollectionKey(\n                this.databaseName,\n                this.collectionName,\n                this.schema.version\n            )\n        );\n        await this.close();\n    }\n\n    close(): Promise<void> {\n        if (this.closed) {\n            return Promise.reject(new Error('already closed'));\n        }\n        this.closed = true;\n\n        this.internals.refCount = this.internals.refCount - 1;\n        return PROMISE_RESOLVE_VOID;\n    }\n\n    conflictResultionTasks(): Observable<RxConflictResultionTask<RxDocType>> {\n        return this.internals.conflictResultionTasks$.asObservable();\n    }\n    resolveConflictResultionTask(_taskSolution: RxConflictResultionTaskSolution<RxDocType>): Promise<void> {\n        return PROMISE_RESOLVE_VOID;\n    }\n}\n\nexport function createMemoryStorageInstance<RxDocType>(\n    storage: RxStorageMemory,\n    params: RxStorageInstanceCreationParams<RxDocType, RxStorageMemoryInstanceCreationOptions>,\n    settings: RxStorageMemorySettings\n): Promise<RxStorageInstanceMemory<RxDocType>> {\n    const collectionKey = getMemoryCollectionKey(\n        params.databaseName,\n        params.collectionName,\n        params.schema.version\n    );\n\n    let internals = storage.collectionStates.get(collectionKey);\n    if (!internals) {\n        internals = {\n            removed: false,\n            refCount: 1,\n            documents: new Map(),\n            attachments: params.schema.attachments ? new Map() : undefined as any,\n            byIndex: {},\n            conflictResultionTasks$: new Subject(),\n            changes$: new Subject()\n        };\n        addIndexesToInternalsState(internals, params.schema);\n        storage.collectionStates.set(collectionKey, internals);\n    } else {\n        internals.refCount = internals.refCount + 1;\n    }\n\n    const instance = new RxStorageInstanceMemory(\n        storage,\n        params.databaseName,\n        params.collectionName,\n        params.schema,\n        internals,\n        params.options,\n        settings\n    );\n    return Promise.resolve(instance);\n}\n"],"mappings":"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"}