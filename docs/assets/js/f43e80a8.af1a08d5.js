"use strict";(self.webpackChunkrxdb=self.webpackChunkrxdb||[]).push([[8673],{4463:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var r=t(5893),i=t(1151);const s={},o="RxDB Server",a={id:"rx-server",title:"RxDB Server",description:"The RxDB Server Plugin makes it possible to spawn a server on top of a RxDB database that offers multiple types of endpoints for various usages. It can spawn basic CRUD REST endpoints or event realtime replication endpoints that can be used by the client devices to replicate data.",source:"@site/docs/rx-server.md",sourceDirName:".",slug:"/rx-server",permalink:"/rx-server",draft:!1,unlisted:!1,editUrl:"https://github.com/pubkey/rxdb/tree/master/docs-src/docs/rx-server.md",tags:[],version:"current",frontMatter:{}},d={},l=[{value:"Missing features",id:"missing-features",level:2},{value:"Query modifier",id:"query-modifier",level:2},{value:"Change validator",id:"change-validator",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"rxdb-server",children:"RxDB Server"}),"\n",(0,r.jsx)(n.p,{children:"The RxDB Server Plugin makes it possible to spawn a server on top of a RxDB database that offers multiple types of endpoints for various usages. It can spawn basic CRUD REST endpoints or event realtime replication endpoints that can be used by the client devices to replicate data."}),"\n",(0,r.jsx)(n.h1,{id:"replication-endpoint",children:"Replication Endpoint"}),"\n",(0,r.jsxs)(n.p,{children:["The replication endpoint allows clients that connect to it to replicate data with the server via the RxDB ",(0,r.jsx)(n.a,{href:"/replication.html",children:"replication protocol"}),". There is also the ",(0,r.jsx)(n.a,{href:"/replication-server",children:"Replication Server"})," plugin that is used on the client side to connect to the endpoint."]}),"\n",(0,r.jsx)(n.h1,{id:"rest-endpoint",children:"REST endpoint"}),"\n",(0,r.jsx)(n.h1,{id:""}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Authentication (who are you) with the authHandler"}),"\n",(0,r.jsx)(n.li,{children:"authorization with queryModifier and changeValidator"}),"\n",(0,r.jsx)(n.li,{children:"cors"}),"\n",(0,r.jsx)(n.li,{children:"conflict detection with the conflictHandler"}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"server-only-indexes",children:"Server-only indexes"}),"\n",(0,r.jsxs)(n.p,{children:["Normal RxDB schema indexes get the ",(0,r.jsx)(n.code,{children:"_deleted"})," field prepended because all ",(0,r.jsx)(n.a,{href:"/rx-query.html",children:"RxQueries"})," automatically only search for documents with ",(0,r.jsx)(n.code,{children:"_deleted=false"}),".\nWhen you use RxDB on a server, this might not be optimal because there can be the need to query for documents where the value of ",(0,r.jsx)(n.code,{children:"_deleted"})," does not mather. Mostly this is required in the ",(0,r.jsx)(n.a,{href:"/replication.html#checkpoint-iteration",children:"pull.stream$"})," of a replication."]}),"\n",(0,r.jsxs)(n.p,{children:["To set indexes without ",(0,r.jsx)(n.code,{children:"_deleted"}),", you can use the ",(0,r.jsx)(n.code,{children:"internalIndexes"})," field of the schema like the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'  {\n    "version": 0,\n    "primaryKey": "id",\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string",\n            "maxLength": 100 // <- the primary key must have set maxLength\n        },\n        "name": {\n            "type": "string",\n            "maxLength": 100\n        }\n    },\n    "internalIndexes": [\n        ["name", "id"]\n    ]\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"NOTICE:"})," Indexes come with a performance burden. You should only use the indexes you need and make sure you do not accidentally set the ",(0,r.jsx)(n.code,{children:"internalIndexes"})," in your client side ",(0,r.jsx)(n.a,{href:"/rx-collection.html",children:"RxCollections"}),"."]}),"\n",(0,r.jsx)(n.h1,{id:"server-only-fields",children:"Server-only fields"}),"\n",(0,r.jsx)(n.h2,{id:"missing-features",children:"Missing features"}),"\n",(0,r.jsx)(n.p,{children:"The server plugin is in beta mode and some features are still missing. Make a Pull Request when you need them:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"query-modifier",children:"Query modifier"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"RxServerQueryModifier"})}),"\n",(0,r.jsxs)(n.p,{children:["NOTICE: For performance reasons the ",(0,r.jsx)(n.code,{children:"RxServerQueryModifier"})," and ",(0,r.jsx)(n.code,{children:"RxServerChangeValidator"})," MUST NOT be async and return a promise. If you need async data to run them, you should gather that data in  the ",(0,r.jsx)(n.code,{children:"RxServerAuthHandler"})," and store it in the auth data to access it later."]}),"\n",(0,r.jsx)(n.h2,{id:"change-validator",children:"Change validator"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"RxServerChangeValidator"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>o});var r=t(7294);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);